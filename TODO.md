In progress: structs!

 - we have
    - top-level    struct S { field: type, ... }
    - constructor  new S { field: value, ... }
    - read         ... = s.field
    - write        s.field = ...
    - predicate    x is S
    - downcast     x as S
 - done with parsing, type checking, mostly desugaring, mostly wasting
 - more work in flattening
 - wasting of 'null' doesn't really work without nullref; how can we
   propagate this value in the compiler and where do we do it and
   how do we rewrite the tree?
     - the type checker must do it
     - the type checker could have a Type::NullRef that is generated by null
     - NullRef is compatible with CookedRef(T):
        CookedRef(T) == NullRef [also reversed]
        CookedRef(T) != NullRef [ditto]
	x = v is ok if x is CookedRef(T) and v is nullref, for
	  any kind of "=" (param, result, actual assignment)
	v is T / v as T are fine if v is NullRef
     - but the thing is, once we have determined that there was
       a compatible NullRef, we must somehow update the type of
       the expression that was NullRef, or update that expression.
       But that expression is *always* just a null reference and
       we should assert that.  (Interesting case is "f(null as T)",
       but it's important to realize that the type of the argument
       expression is T, not null; "null as T":T.)  So when Null
       meets something it becomes the something, thus NullRef is
       always shallow.  So type comparisons that
       compare references are complex, can we set the apart from
       other type comparisons?  Possibly, because the operators
       on types are few or distinct.  Only == and != overlap with
       other types.  Well, and assignment, parameter passing,
       value returning, possibly more :-/
 - a little work in desugaring which will introduce a new ast node for trap
 - a little more work in wasting to handle new ast node


Other things in flight for MVP "simple programming language":

Testing with `cargo test`:

  - ===> need tests for lots of things

Lexer / parser:

  - ===> Better lexer - what we have does not work well for strings and %%JS
  - ===> Comments
  - Propagate errors up the tree, do not panic
  - Probably a "continue" thing
  - Unlabeled break and continue
  - Return stmt
  - true, false literals
  - Block expressions (for scoping)
  - One-armed "if" for void contexts
  - "else if" thing, not currently allowed

Env:

  - More intrinsincs, esp for type conversion

Type checker:

  - Propagate errors up the tree, do not panic
  - Support unlabeled break and continue
  - Return stmt
  - Continue stmt
  - Block expressions
  - ===> implicit widening of literals

Desugarer:

  - Expand true, false
  - Support unlabeled break and continue, add labels
  - Return stmt
  - Continue stmt
  - Block expressions

Optimizer (does not yet exist):

 - basic constant propagation will get rid of misc temporaries introduced by the
   desugaring

Flattener:

  - ===> Use better gensym tagging for locals
  - Return stmt
  - Continue stmt

Waster:

  - Support more intrinsics
  - Return stmt
