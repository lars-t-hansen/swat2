// -*- mode: rust -*-

// See MANUAL.txt for a concise summary of the grammar.

use ast::*;
use std::str::FromStr;

grammar;

pub Program: Program = {
    <items:TopItem*> => Program { items }
}

TopItem: TopItem = {
    "module" <name:Id> "{" <items:ModItem*> "}" => TopItem::Mod(Module { name, items }),
    <text:JSItem> => TopItem::Js(text)
}

ModItem: ModItem = {
    <v:Visibility> <mutable:VarOrConst> <name:Id> ":" <ty:Type> "=" <init:Expr> ";" => {
        let (exported, imported) = v;
        ModItem::Var(Box::new(GlobalVar {mutable, exported, imported, name, ty, init}))
    },

    <v:Visibility> "fn" <name:Id> <formals:Formals> <retn:Return?> <body:Block> => {
        let (exported, imported) = v;
        ModItem::Fn(Box::new(FnDef {exported, imported, name, formals, retn, body}))
    }
}

Formals: Vec<(Id, Type)> = {
    "(" <fs:(<Formal> ",")*> <f:Formal?> ")" =>
        match f {
            None => fs,
            Some(x) => { let mut v = fs; v.push(x); v }
        }
}
        
Formal: (Id, Type) = {
    <name:Id> ":" <t:Type> => (name, t)
}

Return: Type = {
    "->" <t:Type> => t
}

Block: Box<Block> = {
    "{" <first:BlockItem> <middle:(";" <BlockItem>)*> ";"? "}" => {
        let mut items = middle;
        items.insert(0, first);
        Box::new(Block { items })
    }
}

BlockItem: BlockItem = {
    "let" <name:Id> ":" <ty:Type> "=" <init:Expr> => BlockItem::Let(Box::new(LetDefn {name, ty, init})),
    <e:Expr> => BlockItem::Expr(e)
}

Visibility: (bool, bool) = {
    <v:Visibility2?> => if let Some(e) = v { e } else { (false, false) }
}
        
Visibility2: (bool, bool) = {
    "pub" => (true, false),
    "extern" => (false, true)
}

VarOrConst: bool = {
    "var" => true,
    "const" => false
}

Type: Type = {
    "i32" => Type::I32,
    "i64" => Type::I64,
    "f32" => Type::F32,
    "f64" => Type::F64,
    "anyref" => Type::AnyRef
}

Expr: Box<Expr> = {
    Expr0
}

Expr0: Box<Expr> = {
    <lhs:Expr0> <op:Relop> <rhs:Expr1> => Box::new(Expr::Binop{op,lhs,rhs}),
    Expr1
}

Expr1: Box<Expr> = {
    <lhs:Expr1> <op:Addop> <rhs:Expr2> => Box::new(Expr::Binop{op,lhs,rhs}),
    Expr2
}

Expr2: Box<Expr> = {
    "if" <test:Expr> <consequent:Block> "else" <alternate:Block> => Box::new(Expr::If{test,consequent,alternate}),
    "while" <test:Expr> <body:Block> => Box::new(Expr::While{test,body}),
    "(" <e:Expr> ")" => e,
    <name:Id> <actuals:Actuals?> => {
        if let Some(actuals) = actuals {
            Box::new(Expr::Call{name, actuals})
        } else {
            Box::new(Expr::Id(name))
        }
    },
    <n:IntLit> => {
        let bs = n.as_bytes();
        match char::from(bs[bs.len()-1]) {
            'i' | 'I' => {
                match i32::from_str_radix(&n[..n.len()-1], 10) {
                    Ok(v) => Box::new(Expr::NumLit(Number::I32(v))),
                    Err(_) => panic!("Not a valid i32 literal {}", n)
                }
            }
            'l' | 'L' => {
                match i64::from_str_radix(&n[..n.len()-1], 10) {
                    Ok(v) => Box::new(Expr::NumLit(Number::I64(v))),
                    Err(_) => panic!("Not a valid i64 literal {}", n)
                }
            }
            _ => {
                match i32::from_str_radix(&n, 10) {
                    Ok(v) => Box::new(Expr::NumLit(Number::I32(v))),
                    Err(_) => panic!("Not a valid int literal {}", n)
                }
            }
        }
    },
    <n:FloatLit> => {
        let bs = n.as_bytes();
        match char::from(bs[bs.len()-1]) {
            'f' | 'F' => {
                match f32::from_str(&n[..n.len()-1]) {
                    Ok(v) => Box::new(Expr::NumLit(Number::F32(v))),
                    Err(_) => panic!("Not a valid f32 literal {}", n)
                }
            }
            'd' | 'D' => {
                match f64::from_str(&n[..n.len()-1]) {
                    Ok(v) => Box::new(Expr::NumLit(Number::F64(v))),
                    Err(_) => panic!("Not a valid f64 literal {}", n)
                }
            }
            _ => {
                match f64::from_str(&n) {
                    Ok(v) => Box::new(Expr::NumLit(Number::F64(v))),
                    Err(_) => panic!("Not a valid f64 literal {}", n)
                }
            }
        }
    }
}

Actuals: Vec<Box<Expr>> = {
    "(" <es:(<Expr> ",")*> <e:Expr?> ")" =>
        match e {
            None => es,
            Some(x) => { let mut v = es; v.push(x); v }
        }
}
    
Relop: Binop = {
    "<"   => Binop::Less,
    "<="  => Binop::LessOrEqual,
    ">"   => Binop::Greater,
    ">="  => Binop::GreaterOrEqual,
    "<u"  => Binop::ULess,
    "<=u" => Binop::ULessOrEqual,
    ">u"  => Binop::UGreater,
    ">=u" => Binop::UGreaterOrEqual,
    "=="  => Binop::Equal,
    "!="  => Binop::NotEqual
}

Addop: Binop = {
    "+" => Binop::Add,
    "-" => Binop::Sub
}

Mulop: Binop = {
    "*" => Binop::Mul,
    "/" => Binop::Div,
    "%" => Binop::Rem,
    "/u" => Binop::UDiv,
    "%u" => Binop::URem
}

Id: Id = {
    <n:Name> => Id{name:n}
}

Name: String = <s:r"[a-zA-Z_][a-zA-Z_0-9$]*"> => String::from_str(s).unwrap();
IntLit: String = <s:r"[0-9]+[iIlL]?"> => String::from_str(s).unwrap();
FloatLit: String = <s:r"[0-9]+[fFdD]|[0-9]+\\.[0-9]+([eE][+-]?[0-9]+)?[fFdD]?"> => String::from_str(s).unwrap();
JSItem: String = <s:r"js<!<.*>!>"> => String::from_str(s).unwrap();
